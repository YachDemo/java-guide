# Java

## 集合概述

### Java集合概述

从下图看出，在Java中除了以Map结尾的类之外，其他类都实现了```Collection```接口。

并且，以Map结尾的都实现了```Map```接口。

![集合](https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg "集合")

### 说说List，Set，Map三者的区别

- ```List```：存储元素是有序可重复的
- ```Set```：无序且不重复
- ```Map```：使用键值对存储（key-value）存储，类似于数学上的函数y=f(x)，其中x表示key，“y”代表value，Key是无序的，value是无序的，可重复的，每个键最多映射一个值。

## 集合框架底层数据结构总结

先来看一下```Collection```接口下面的集合

### List

- ```ArrayList```：```Object[]```数组
- ```Vector```：```Object[]```数组
- ```LinkedList```：双向链表（JDK1.6之前为循环链表，JDK1.7取消了循环）

### Set

- ```HashSet```（无序，唯一）：底层基于```HashMap```实现的，底层采用```HashMap```来保存元素
- ```LinkedHashSet```：```LinkedHashSet```是```HashSet```的子类，并且内部是通过```LinkedHashMap```来实现的。有点类似于我们之前说的```LinkedHashMap```是基于```HashMap```实现的一样，不过还是有点区别的
- ```TreeSet```（有序，唯一）：红黑树（自平衡的排序二叉树）

再来看看```Map```接口下的集合。

### Map

- ```HashMap```：JDK1.8之前```HashMap```由数组+链表组成的，数组是HashMap的主体。链表则是主要为了解决哈希冲突而存在的（”拉链法“解决冲突）。JDK1.8以后在解决哈希冲突时有了较大变化，当链表长度大于阈值（默认为8）（将链表转为红黑树前会判断，如果当前数组长度小于64，那么先会选择数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间
- ```LinkedHashMap```：LinkedHashMap继承自HashMap，所以他的底层仍然是基于拉链式散链结构即数组和链表或红黑树组成，另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对插入的顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
- ```Hashtable```：数组+链表组成的，数组是Hashtable的主体，链表则是为了解决哈希冲突而存在的
- ```TreeMap```：红黑树（自平衡的排序二叉树）

## 为什么要使用集合

当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象有一定的弊端，因为我们在实际的开发中，存储的数据类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。

数组的缺点是一旦声明了之后，长度就不可变了；同时，声明数组的数据类型也决定了该数组存储数据的数据类型；而且，数组存储的数据是有序的，可重复的，特点单一。集合提高了数据存储的灵活性，Java集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据

## Iterator迭代器

### Iterator是什么

```java
public interface Iterator<E> {
    // 集合中是否还有元素
    boolean hasNext();
    // 或得集合中下一个元素
    E next();
    ...
}
```

```Iterator```对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取很可能是不一样的，虽然我们可以人为的在每一个类中定义```hashNext()```和```next()```方法，但这样会让整个集合体系过于臃肿。于是就有了迭代器。

迭代器是将这样的方法抽取出接口，然后在每个类的内部定义，定义自己的迭代方式，这样做规定了整个集合体系的遍历方式都是```hasNext()```和```next()```方法，使用者不管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节
